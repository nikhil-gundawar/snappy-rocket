<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flappy Rocket - Nebula Edition</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000000">
<style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; margin: auto; background: transparent; }
    #overlay {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.7);
        color: white;
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 24px;
        z-index: 10;
        text-align: center;
        padding: 20px;
    }
</style>
</head>
<body>
<div id="overlay"></div>
<canvas id="gameCanvas" width="480" height="640"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let overlay = document.getElementById("overlay");

let spaceshipImg = new Image();
spaceshipImg.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d4/Spaceship_icon.svg/256px-Spaceship_icon.svg.png";

let rocket, pipes, frame, score, gameOver, playing, speed, gap, startTime;
let lastDifficultyIncrease = 0;
let stars = [];

// Create moving pastel nebula background
function drawNebulaBackground(time) {
    let gradient = ctx.createRadialGradient(
        canvas.width/2 + Math.sin(time/3000)*50,
        canvas.height/2 + Math.cos(time/4000)*50,
        50,
        canvas.width/2,
        canvas.height/2,
        canvas.width
    );
    gradient.addColorStop(0, "rgba(180,150,255,0.6)");
    gradient.addColorStop(0.5, "rgba(120,100,200,0.4)");
    gradient.addColorStop(1, "rgba(0,0,40,0.8)");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// Starfield for depth
function initStars() {
    stars = [];
    for (let i = 0; i < 80; i++) {
        stars.push({
            x: Math.random()*canvas.width,
            y: Math.random()*canvas.height,
            size: Math.random()*2,
            speed: Math.random()*0.5 + 0.2
        });
    }
}
function drawStars() {
    ctx.fillStyle = "white";
    stars.forEach(s => {
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
        ctx.fill();
        s.y += s.speed;
        if (s.y > canvas.height) s.y = 0;
    });
}

function resetGame() {
    rocket = { x: 50, y: 150, width: 40, height: 30, velocity: 0, gravity: 0.5, lift: -8 };
    pipes = [];
    frame = 0;
    score = 0;
    gameOver = false;
    playing = false;
    speed = 2;
    gap = 150;
    startTime = null;
    initStars();
}

function drawRocket() {
    ctx.drawImage(spaceshipImg, rocket.x, rocket.y, rocket.width, rocket.height);
}

function drawPipes(time) {
    pipes.forEach(pipe => {
        if (pipe.isBanner) {
            let glow = ctx.createRadialGradient(
                pipe.x + pipe.width/2, pipe.y + pipe.height/2, 10,
                pipe.x + pipe.width/2, pipe.y + pipe.height/2, 80
            );
            glow.addColorStop(0, "rgba(200,150,255,0.9)");
            glow.addColorStop(1, "rgba(200,150,255,0)");
            ctx.fillStyle = glow;
            ctx.fillRect(pipe.x-40, pipe.y-40, pipe.width+80, pipe.height+80);

            ctx.fillStyle = "rgba(180,150,255,0.9)";
            ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
            ctx.fillStyle = "#fff";
            ctx.font = "bold 14px Arial";
            ctx.fillText("slice Credit Card", pipe.x + 3, pipe.y + pipe.height/2+5);
        } else {
            ctx.fillStyle = "#FF4444";
            ctx.strokeStyle = "#FFFFFF";
            ctx.lineWidth = 2;
            ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
            ctx.strokeRect(pipe.x, 0, pipe.width, pipe.top);
            ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipe.width, pipe.bottom);
            ctx.strokeRect(pipe.x, canvas.height - pipe.bottom, pipe.width, pipe.bottom);
        }
    });
}

function updatePipes() {
    if (frame % 90 === 0) {
        let top = Math.random() * (canvas.height - gap - 100) + 50;
        let bottom = canvas.height - top - gap;
        let isBanner = Math.random() < 0.1;
        pipes.push({
            x: canvas.width, width: 40, top: top, bottom: bottom, isBanner: isBanner, 
            y: isBanner ? Math.random()*canvas.height/2 + 100 : null,
            height: isBanner ? 50 : null
        });
    }
    pipes.forEach(pipe => { pipe.x -= speed; });
    pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
}

function checkCollision() {
    if (rocket.y + rocket.height >= canvas.height || rocket.y <= 0) gameOver = true;
    pipes.forEach(pipe => {
        if (!pipe.isBanner &&
            rocket.x < pipe.x + pipe.width &&
            rocket.x + rocket.width > pipe.x &&
            (rocket.y < pipe.top || rocket.y + rocket.height > canvas.height - pipe.bottom)
        ) {
            gameOver = true;
        }
    });
}

function drawScore() {
    ctx.fillStyle = "white";
    ctx.font = "24px Arial";
    ctx.fillText(`Score: ${score}`, 10, 30);
}

function loop(timestamp) {
    drawNebulaBackground(timestamp);
    drawStars();
    if (!playing) return;

    drawRocket();
    drawPipes(timestamp);
    drawScore();

    rocket.velocity += rocket.gravity;
    rocket.y += rocket.velocity;
    updatePipes();
    checkCollision();

    if (!startTime) startTime = timestamp;
    let elapsed = (timestamp - startTime) / 1000;
    if (elapsed > 30 && elapsed - lastDifficultyIncrease >= 10) {
        speed += speed * 0.07;
        gap -= gap * 0.07;
        lastDifficultyIncrease = elapsed;
    }

    pipes.forEach(pipe => {
        if (!pipe.isBanner && pipe.x + pipe.width === rocket.x) score++;
    });
    frame++;
    if (!gameOver) {
        requestAnimationFrame(loop);
    } else {
        showGameOver();
    }
}

function showGameOver() {
    overlay.innerHTML = `<div>Game Over</div><div>Score: ${score}</div><div>Tap to Restart</div>`;
    overlay.style.display = "flex";
}

function showTutorial() {
    let seconds = 5;
    overlay.innerHTML = `<div>Tap to thrust upward. Avoid obstacles.</div><div>Starting in ${seconds}...</div>`;
    overlay.style.display = "flex";
    let countdown = setInterval(() => {
        seconds--;
        overlay.innerHTML = `<div>Tap to thrust upward. Avoid obstacles.</div><div>Starting in ${seconds}...</div>`;
        if (seconds <= 0) {
            clearInterval(countdown);
            overlay.style.display = "none";
            playing = true;
            requestAnimationFrame(loop);
        }
    }, 1000);
}

document.addEventListener("keydown", () => { if (playing) rocket.velocity = rocket.lift; });
document.addEventListener("touchstart", () => { 
    if (gameOver) {
        overlay.style.display = "none";
        resetGame();
        showTutorial();
    } else if (!playing) {
        overlay.style.display = "none";
        playing = true;
        requestAnimationFrame(loop);
    } else {
        rocket.velocity = rocket.lift;
    }
});

resetGame();
showTutorial();
</script>
<script>
// PWA service worker registration
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('sw.js').then(function(registration) {
      console.log('ServiceWorker registered with scope:', registration.scope);
    }).catch(function(err) {
      console.log('ServiceWorker registration failed:', err);
    });
  });
}
</script>
</body>
</html>
